const fs = require('fs');
const path = require('path');
const turf = require('@turf/turf');

// --- Configuration ---
// AFTER
const INPUT_GEOJSON_PATH = path.join(__dirname, '..', 'data', 'walkways.geojson');
const OUTPUT_HELPER_PATH = path.join(__dirname, 'data', 'SEEU_walkway.js');
const SCALE_FACTOR = 1000; // Adjust to make the model bigger or smaller

console.log('Starting GeoJSON processing...');

// 1. Read and parse the source file
let geojson;
try {
    const fileContent = fs.readFileSync(INPUT_GEOJSON_PATH, 'utf8');
    geojson = JSON.parse(fileContent);
} catch (error) {
    console.error(`Error reading or parsing ${INPUT_GEOJSON_PATH}:`, error);
    process.exit(1);
}

// 2. Separate main polygons from hole polygons
const mainFeatures = geojson.features.filter(f => f.properties.fill === '#000000' || !f.properties.fill);
const holeFeatures = geojson.features.filter(f => f.properties.fill === '#ff0000');

if (mainFeatures.length === 0) {
    console.error('No main polygons (black fill) found in the GeoJSON. Aborting.');
    process.exit(1);
}
console.log(`Found ${mainFeatures.length} main polygon(s) and ${holeFeatures.length} potential hole(s).`);


// 3. Find the center of the entire scene for normalization
const allPoints = geojson.features.flatMap(f => turf.coordAll(f));
const center = turf.center(turf.featureCollection(allPoints.map(p => turf.point(p)))).geometry.coordinates;
console.log(`Calculated scene center at [${center[0].toFixed(6)}, ${center[1].toFixed(6)}]`);


// 4. Process each main feature to find its holes and normalize coordinates
const processedShapesData = mainFeatures.map(mainFeature => {
    // Find holes that are geometrically inside this main feature
    const associatedHoles = holeFeatures
        .filter(holeFeature => turf.booleanContains(mainFeature, holeFeature))
        .map(holeFeature => {
            // Normalize hole coordinates
            return holeFeature.geometry.coordinates[0].map(coord => [
                (coord[0] - center[0]) * SCALE_FACTOR,
                (coord[1] - center[1]) * SCALE_FACTOR
            ]);
        });

    // Normalize outer boundary coordinates
    const normalizedOuter = mainFeature.geometry.coordinates[0].map(coord => [
        (coord[0] - center[0]) * SCALE_FACTOR,
        (coord[1] - center[1]) * SCALE_FACTOR
    ]);

    return {
        outer: normalizedOuter,
        holes: associatedHoles
    };
});

// 5. Generate the JavaScript module string
const fileTemplate = `
import * as THREE from 'three';

// This file is auto-generated by process-geojson.js. Do not edit manually.

const processedShapesData = ${JSON.stringify(processedShapesData, null, 2)};

/**
 * Creates the 3D walkway meshes from pre-processed GeoJSON data.
 * @returns {THREE.Group} A group containing all the walkway meshes.
 */
export function createWalkwayMeshes() {
    const group = new THREE.Group();

    const walkwayMaterial = new THREE.MeshStandardMaterial({
        color: 0x333333, // A dark gray color for the walkways
        side: THREE.DoubleSide,
        metalness: 0.1,
        roughness: 0.8
    });

    const extrudeSettings = {
        steps: 1,
        depth: 0.1, // The "thickness" of the walkways
        bevelEnabled: false,
    };

    processedShapesData.forEach(data => {
        // Create the outer shape
        const outerPath = data.outer.map(p => new THREE.Vector2(p[0], p[1]));
        const shape = new THREE.Shape(outerPath);

        // Create and add the holes
        if (data.holes.length > 0) {
            data.holes.forEach(holePoints => {
                const holePath = holePoints.map(p => new THREE.Vector2(p[0], p[1]));
                shape.holes.push(new THREE.Path(holePath.reverse())); // Holes need opposite winding order
            });
        }
        
        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const mesh = new THREE.Mesh(geometry, walkwayMaterial);
        
        // Rotate to lay flat on the XZ plane
        mesh.rotation.x = -Math.PI / 2;

        group.add(mesh);
    });

    return group;
}
`;

// 6. Write the generated module to the helper directory
try {
    if (!fs.existsSync(path.dirname(OUTPUT_HELPER_PATH))) {
        fs.mkdirSync(path.dirname(OUTPUT_HELPER_PATH));
    }
    fs.writeFileSync(OUTPUT_HELPER_PATH, fileTemplate.trim());
    console.log(`âœ… Success! Helper module written to ${OUTPUT_HELPER_PATH}`);
} catch (error) {
    console.error(`Error writing output file:`, error);
}